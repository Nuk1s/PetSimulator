-- UltimatePetSystem.lua - –ò–î–ï–ê–õ–¨–ù–ê–Ø —Å–∏—Å—Ç–µ–º–∞ —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –≤—Å–µ—Ö –ø—Ä–æ–±–ª–µ–º
-- –ü–æ–º–µ—Å—Ç–∏—Ç–µ –≤ ServerScriptService

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

print("üêæ Ultimate Pet System Loading...")

-- –ü–æ–∏—Å–∫ –ø–∏—Ç–æ–º—Ü–µ–≤
local petsFolder = nil
local function findPetsRecursively(parent)
	if not parent then return nil end

	for _, child in pairs(parent:GetChildren()) do
		if child.Name == "PETS" and child:IsA("Folder") then
			local pets1 = child:FindFirstChild("PETS 1")
			if pets1 then
				petsFolder = pets1
				return pets1
			end
		end
		if child:IsA("Folder") or child:IsA("Model") then
			local result = findPetsRecursively(child)
			if result then return result end
		end
	end
end

petsFolder = findPetsRecursively(ReplicatedStorage)
if not petsFolder then
	warn("‚ùå –ü–∞–ø–∫–∞ —Å –ø–∏—Ç–æ–º—Ü–∞–º–∏ –ù–ï –ù–ê–ô–î–ï–ù–ê!")
	return
end

print("‚úÖ –ü–∏—Ç–æ–º—Ü—ã –Ω–∞–π–¥–µ–Ω—ã: " .. petsFolder:GetFullName())

-- Remote Events
local remoteEvents = ReplicatedStorage:FindFirstChild("RemoteEvents")
if not remoteEvents then
	remoteEvents = Instance.new("Folder")
	remoteEvents.Name = "RemoteEvents"
	remoteEvents.Parent = ReplicatedStorage
end

local function getOrCreateRemoteEvent(name)
	local re = remoteEvents:FindFirstChild(name)
	if not re then
		re = Instance.new("RemoteEvent")
		re.Name = name
		re.Parent = remoteEvents
	end
	return re
end

local RE_EquipPet = getOrCreateRemoteEvent("RE_EquipPet")
local RE_UnequipPet = remoteEvents:FindFirstChild("RE_RequestUnequipPet") or getOrCreateRemoteEvent("RE_UnequipPet")
local RE_UpdatePets = getOrCreateRemoteEvent("RE_UpdatePets")
local RE_UpdateCoins = getOrCreateRemoteEvent("RE_UpdateCoins")
local RE_SmartAttack = getOrCreateRemoteEvent("RE_SmartAttack")
local RE_RecallAllPets = getOrCreateRemoteEvent("RE_RecallAllPets")
local RE_DeletePet = getOrCreateRemoteEvent("RE_DeletePet")
local RE_EquipBest = getOrCreateRemoteEvent("RE_EquipBest")
local RE_UnequipAll = getOrCreateRemoteEvent("RE_UnequipAll")

-- –î–∞–Ω–Ω—ã–µ
local PlayerData = {}
local activePets = {}
local attackedObjects = {}

-- –ü–†–ê–í–ò–õ–¨–ù–´–ï –§–û–†–ú–ê–¶–ò–ò (1-2-3: –ª–µ–≤—ã–π, —Ü–µ–Ω—Ç—Ä, –ø—Ä–∞–≤—ã–π)
local PERFECT_FORMATIONS = {
	[1] = {Vector3.new(0, 0, 6)}, -- 1 –ø–∏—Ç–æ–º–µ—Ü - –¶–ï–ù–¢–†
	[2] = {Vector3.new(-4, 0, 6), Vector3.new(4, 0, 6)}, -- 2 –ø–∏—Ç–æ–º—Ü–∞ - –õ–ï–í–´–ô, –ü–†–ê–í–´–ô
	[3] = {Vector3.new(-5, 0, 6), Vector3.new(0, 0, 6), Vector3.new(5, 0, 6)}, -- 3 –ø–∏—Ç–æ–º—Ü–∞ - –õ–ï–í–´–ô, –¶–ï–ù–¢–†, –ü–†–ê–í–´–ô
}

local PET_STATES = {
	FOLLOWING = "following",
	ATTACKING = "attacking",
	RETURNING = "returning"
}

-- –ö—Ä–∞—Å–∏–≤–∞—è –æ–±–≤–æ–¥–∫–∞ –æ–±—ä–µ–∫—Ç–æ–≤
local function createBeautifulOutline(object, enable)
	if enable then
		if attackedObjects[object] then return end

		local highlight = Instance.new("Highlight")
		highlight.Name = "AttackOutline"
		highlight.Adornee = object
		highlight.FillColor = Color3.new(0, 0.8, 1)
		highlight.OutlineColor = Color3.new(0, 0.4, 0.8)
		highlight.FillTransparency = 0.7
		highlight.OutlineTransparency = 0
		highlight.Parent = object

		local pulseInfo = TweenInfo.new(1.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
		local pulseTween = TweenService:Create(highlight, pulseInfo, {
			FillTransparency = 0.9,
			OutlineTransparency = 0.3
		})
		pulseTween:Play()

		attackedObjects[object] = {highlight = highlight, tween = pulseTween}
		print("üîµ –ö—Ä–∞—Å–∏–≤–∞—è –æ–±–≤–æ–¥–∫–∞: " .. object.Name)
	else
		if attackedObjects[object] then
			local data = attackedObjects[object]
			if data.tween then data.tween:Cancel() end
			if data.highlight then data.highlight:Destroy() end
			attackedObjects[object] = nil
		end
	end
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ç–∞–∫—É–µ–º—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ (–ò–°–ü–†–ê–í–õ–ï–ù–û: –≤–∫–ª—é—á–µ–Ω—ã —Å—É–Ω–¥—É–∫–∏)
local function isAttackableObject(obj)
	if not obj or not obj.Parent then return false end

	-- –î–æ–±–∞–≤–ª—è–µ–º –±–æ–ª—å—à–µ —Ç–∏–ø–æ–≤ –∞—Ç–∞–∫—É–µ–º—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
	if obj:GetAttribute("CurrentHP") then return true end
	if obj.Name:lower():find("coin") then return true end
	if obj.Name:lower():find("chest") then return true end
	if obj.Name:lower():find("—Å—É–Ω–¥—É–∫") then return true end -- –†—É—Å—Å–∫–∏–π
	if obj.Name:lower():find("block") then return true end
	if obj.Name:lower():find("ore") then return true end
	if obj.Name:lower():find("crate") then return true end
	if obj.Name:lower():find("box") then return true end

	-- –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ —Ç–µ–≥–∞–º/–∞—Ç—Ä–∏–±—É—Ç–∞–º
	if obj:GetAttribute("Attackable") then return true end
	if obj:FindFirstChild("Health") then return true end

	return false
end

-- –°–æ–∑–¥–∞–Ω–∏–µ –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ –ø–∏—Ç–æ–º—Ü–∞
local function createUltimatePet(modelName, player, formationIndex)
	local originalModel = petsFolder:FindFirstChild(modelName)
	if not originalModel then return nil end

	print("üîß –°–æ–∑–¥–∞—é –∏–¥–µ–∞–ª—å–Ω–æ–≥–æ –ø–∏—Ç–æ–º—Ü–∞: " .. modelName)

	local petContainer = Instance.new("Model")
	petContainer.Name = modelName .. "_Pet"

	local visualModel = originalModel:Clone()
	visualModel.Name = "Visual"
	visualModel.Parent = petContainer

	local controller = Instance.new("Part")
	controller.Name = "Controller"
	controller.Size = Vector3.new(0.1, 0.1, 0.1)
	controller.Transparency = 1
	controller.CanCollide = false
	controller.Anchored = false
	controller.Parent = petContainer

	petContainer.PrimaryPart = controller

	-- –û–±—Ä–∞–±–æ—Ç–∫–∞ —á–∞—Å—Ç–µ–π –º–æ–¥–µ–ª–∏
	local modelParts = {}
	local centerPos = Vector3.new(0, 0, 0)
	local partCount = 0
	local minY = math.huge
	local maxY = -math.huge

	for _, part in pairs(visualModel:GetDescendants()) do
		if part:IsA("BasePart") then
			table.insert(modelParts, part)
			part.CanCollide = false -- –ù–µ —Ç–æ–ª–∫–∞—é—Ç –∏–≥—Ä–æ–∫–∞
			part.Anchored = false

			centerPos = centerPos + part.Position
			partCount = partCount + 1

			local partTop = part.Position.Y + (part.Size.Y / 2)
			local partBottom = part.Position.Y - (part.Size.Y / 2)
			minY = math.min(minY, partBottom)
			maxY = math.max(maxY, partTop)
		end
	end

	if partCount > 0 then
		centerPos = centerPos / partCount
	end

	controller.Position = Vector3.new(centerPos.X, minY, centerPos.Z)

	-- –ü—Ä–∏–≤–∞—Ä–∏–≤–∞–µ–º —á–∞—Å—Ç–∏
	for _, part in pairs(modelParts) do
		local offsetPosition = part.Position - controller.Position

		local weld = Instance.new("WeldConstraint")
		weld.Part0 = controller
		weld.Part1 = part
		weld.Parent = controller

		part.Position = controller.Position + offsetPosition
	end

	-- –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
	local bodyPos = Instance.new("BodyPosition")
	bodyPos.MaxForce = Vector3.new(8000, 8000, 8000)
	bodyPos.P = 6000
	bodyPos.D = 1200
	bodyPos.Position = controller.Position
	bodyPos.Parent = controller

	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(0, 8000, 0)
	bodyGyro.P = 6000
	bodyGyro.D = 1000
	bodyGyro.CFrame = controller.CFrame
	bodyGyro.Parent = controller

	-- –ò–º—è –ø–∏—Ç–æ–º—Ü–∞
	local modelHeight = maxY - minY
	local attachment = Instance.new("Attachment")
	attachment.Position = Vector3.new(0, modelHeight + 1.2, 0)
	attachment.Parent = controller

	local nameGui = Instance.new("BillboardGui")
	nameGui.Size = UDim2.new(0, 100, 0, 30)
	nameGui.StudsOffset = Vector3.new(0, 0, 0)
	nameGui.Parent = attachment

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, 0, 1, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Text = modelName
	nameLabel.TextColor3 = Color3.new(1, 1, 1)
	nameLabel.Font = Enum.Font.GothamMedium
	nameLabel.TextSize = 16
	nameLabel.TextStrokeTransparency = 0
	nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	nameLabel.Parent = nameGui

	petContainer:SetAttribute("PetOwner", player.Name)
	petContainer:SetAttribute("PetName", modelName)
	petContainer:SetAttribute("FormationIndex", formationIndex)
	petContainer:SetAttribute("State", PET_STATES.FOLLOWING)

	return petContainer
end

-- –ó–∞–ø—É—Å–∫ –ò–ò –ø–∏—Ç–æ–º—Ü–∞
local function startUltimatePetAI(petModel, player, formationIndex)
	if not petModel.PrimaryPart then return end

	local controller = petModel.PrimaryPart
	local bodyPos = controller:FindFirstChild("BodyPosition")
	local bodyGyro = controller:FindFirstChild("BodyGyro")

	if not bodyPos or not bodyGyro then return end

	local playerPetCount = 0
	for _, existingPet in pairs(activePets) do
		if existingPet.player == player then
			playerPetCount = playerPetCount + 1
		end
	end

	local formation = PERFECT_FORMATIONS[math.min(3, playerPetCount + 1)] or PERFECT_FORMATIONS[1]
	local positionIndex = ((playerPetCount) % #formation) + 1
	local formationOffset = formation[positionIndex]

	local petData = {
		model = petModel,
		player = player,
		controller = controller,
		bodyPos = bodyPos,
		bodyGyro = bodyGyro,
		formationOffset = formationOffset,
		formationIndex = positionIndex,
		state = PET_STATES.FOLLOWING,
		attackTarget = nil,
		attackAngle = math.random() * math.pi * 2,
		attackRadius = 8,
		isAttacking = false
	}

	table.insert(activePets, petData)
	print("üêï –ü–∏—Ç–æ–º–µ—Ü –≤ AI: " .. petModel:GetAttribute("PetName") .. " (–ø–æ–∑–∏—Ü–∏—è " .. positionIndex .. ")")
end

-- –ò–î–ï–ê–õ–¨–ù–´–ô –≥–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª –ò–ò (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞—Ç–∞–∫–∞ —Å–Ω–∞—Ä—É–∂–∏ –æ–±—ä–µ–∫—Ç–∞)
RunService.Heartbeat:Connect(function(dt)
	for i = #activePets, 1, -1 do
		local petData = activePets[i]

		if not petData.model.Parent or not petData.player.Character then
			table.remove(activePets, i)
			continue
		end

		local character = petData.player.Character
		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then continue end

		local currentState = petData.model:GetAttribute("State")

		if currentState == PET_STATES.FOLLOWING then
			-- –ò–î–ï–ê–õ–¨–ù–û–ï –°–õ–ï–î–û–í–ê–ù–ò–ï: –õ–ï–í–´–ô, –¶–ï–ù–¢–†, –ü–†–ê–í–´–ô
			local playerCFrame = hrp.CFrame
			local targetCFrame = playerCFrame * CFrame.new(petData.formationOffset)
			local targetPos = targetCFrame.Position

			local currentPos = petData.controller.Position
			local distance = (currentPos - targetPos).Magnitude

			if distance > 50 then
				petData.model:SetPrimaryPartCFrame(targetCFrame)
			elseif distance > 2 then -- –ù–µ –ø–æ–¥—Ö–æ–¥—è—Ç —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ
				petData.bodyPos.Position = targetPos

				local lookDir = hrp.CFrame.LookVector
				local playerVel = hrp.Velocity
				if playerVel.Magnitude > 2 then
					lookDir = Vector3.new(playerVel.X, 0, playerVel.Z).Unit
				end

				local targetRot = CFrame.lookAt(petData.controller.Position, petData.controller.Position + lookDir)
				petData.bodyGyro.CFrame = targetRot
			end

		elseif currentState == PET_STATES.ATTACKING then
			-- –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ê–¢–ê–ö–ê: –ø–∏—Ç–æ–º—Ü—ã –∫—Ä—É–∂–∞—Ç—Å—è –°–ù–ê–†–£–ñ–ò –æ–±—ä–µ–∫—Ç–∞
			if petData.attackTarget and petData.attackTarget.Parent then
				local target = petData.attackTarget
				local targetPos = target.PrimaryPart and target.PrimaryPart.Position or target:FindFirstChildOfClass("BasePart").Position

				-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –æ–±—ä–µ–∫—Ç–∞
				local targetSize = Vector3.new(4, 4, 4)
				if target.PrimaryPart then
					targetSize = target.PrimaryPart.Size
				elseif target:FindFirstChildOfClass("BasePart") then
					targetSize = target:FindFirstChildOfClass("BasePart").Size
				end

				-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–∏—Ç–æ–º—Ü—ã –∫—Ä—É–∂–∞—Ç—Å—è –°–ù–ê–†–£–ñ–ò, –Ω–µ –≤–Ω—É—Ç—Ä–∏
				local objectRadius = math.max(targetSize.X, targetSize.Z) / 2
				local safeDistance = objectRadius + 3 -- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ —Å–Ω–∞—Ä—É–∂–∏
				petData.attackRadius = safeDistance + (petData.formationIndex - 1) * 2

				-- –ü–ª–∞–≤–Ω–æ–µ –∫—Ä—É–≥–æ–≤–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –°–ù–ê–†–£–ñ–ò –æ–±—ä–µ–∫—Ç–∞
				petData.attackAngle = petData.attackAngle + dt * 1.5

				local x = targetPos.X + math.cos(petData.attackAngle) * petData.attackRadius
				local z = targetPos.Z + math.sin(petData.attackAngle) * petData.attackRadius
				local y = targetPos.Y + math.sin(petData.attackAngle * 2) * 1 + 2

				petData.bodyPos.Position = Vector3.new(x, y, z)

				-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü–∏—Ç–æ–º—Ü—ã –í–°–ï–ì–î–ê —Å–º–æ—Ç—Ä—è—Ç –Ω–∞ —Ü–µ–ª—å (–≤–Ω—É—Ç—Ä—å)
				local lookDir = (targetPos - petData.controller.Position).Unit
				local targetRot = CFrame.lookAt(petData.controller.Position, petData.controller.Position + lookDir)
				petData.bodyGyro.CFrame = targetRot

				petData.isAttacking = true
			else
				petData.model:SetAttribute("State", PET_STATES.FOLLOWING)
				petData.attackTarget = nil
				petData.isAttacking = false
			end

		elseif currentState == PET_STATES.RETURNING then
			-- –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ
			local playerCFrame = hrp.CFrame
			local targetCFrame = playerCFrame * CFrame.new(petData.formationOffset)
			local targetPos = targetCFrame.Position

			local distance = (petData.controller.Position - targetPos).Magnitude

			if distance < 3 then
				petData.model:SetAttribute("State", PET_STATES.FOLLOWING)
				petData.isAttacking = false
			else
				petData.bodyPos.Position = targetPos

				local lookDir = (hrp.Position - petData.controller.Position).Unit
				local targetRot = CFrame.lookAt(petData.controller.Position, petData.controller.Position + lookDir)
				petData.bodyGyro.CFrame = targetRot
			end
		end
	end
end)

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–∫–∞
local function initPlayer(player)
	print("üë§ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é: " .. player.Name)

	PlayerData[player] = {
		coins = 500,
		pets = {},
		equippedPets = {}
	}

	task.spawn(function()
		task.wait(3)

		local availablePets = petsFolder:GetChildren()
		local giveCount = math.min(6, #availablePets)

		for i = 1, giveCount do
			local petModel = availablePets[i]

			local petData = {
				id = player.Name .. "_pet_" .. i,
				name = petModel.Name,
				damage = 50 + (i * 25),
				coinMultiplier = 1.0 + (i * 0.5),
				modelName = petModel.Name,
				rarity = i <= 2 and "Common" or (i <= 4 and "Uncommon" or "Rare"),
				equipped = false
			}

			table.insert(PlayerData[player].pets, petData)
		end

		RE_UpdatePets:FireClient(player, PlayerData[player].pets, PlayerData[player].equippedPets)
		RE_UpdateCoins:FireClient(player, PlayerData[player].coins)
		print("‚úÖ " .. player.Name .. " –ø–æ–ª—É—á–∏–ª " .. giveCount .. " –ø–∏—Ç–æ–º—Ü–µ–≤")
	end)
end

-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –£–º–Ω–∞—è –∞—Ç–∞–∫–∞ —Ç–æ–ª—å–∫–æ –û–î–ù–ò–ú –ø–∏—Ç–æ–º—Ü–µ–º –∑–∞ —Ä–∞–∑
local function smartAttackSingle(player, targetObject, petIndex)
	if not PlayerData[player] or not targetObject then return end

	-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞—Ç–∞–∫—É–µ–º—ã–π –ª–∏ –æ–±—ä–µ–∫—Ç
	if not isAttackableObject(targetObject) then
		print("‚ùå –û–±—ä–µ–∫—Ç " .. targetObject.Name .. " –Ω–µ –∞—Ç–∞–∫—É–µ–º—ã–π")
		return
	end

	local playerPets = {}
	for _, petData in pairs(activePets) do
		if petData.player == player and petData.model:GetAttribute("State") == PET_STATES.FOLLOWING then
			table.insert(playerPets, petData)
		end
	end

	if #playerPets == 0 then 
		print("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–∏—Ç–æ–º—Ü–µ–≤ –¥–ª—è –∞—Ç–∞–∫–∏")
		return 
	end

	-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –û–î–ù–û–ì–û –ø–∏—Ç–æ–º—Ü–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É
	local targetPet = playerPets[math.min(petIndex, #playerPets)]
	if targetPet then
		targetPet.model:SetAttribute("State", PET_STATES.ATTACKING)
		targetPet.attackTarget = targetObject
		targetPet.attackAngle = math.random() * math.pi * 2

		-- –ö—Ä–∞—Å–∏–≤–∞—è –æ–±–≤–æ–¥–∫–∞ –æ–±—ä–µ–∫—Ç–∞
		createBeautifulOutline(targetObject, true)

		print("‚öîÔ∏è –ü–∏—Ç–æ–º–µ—Ü #" .. petIndex .. " (" .. targetPet.model:GetAttribute("PetName") .. ") –∞—Ç–∞–∫—É–µ—Ç " .. targetObject.Name)

		-- –£—Ä–æ–Ω –ø–æ –æ–±—ä–µ–∫—Ç—É
		task.spawn(function()
			while targetPet.model.Parent and targetPet.model:GetAttribute("State") == PET_STATES.ATTACKING and targetObject.Parent do
				task.wait(1) -- –£—Ä–æ–Ω –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É

				if _G.SpawnerAPI and _G.SpawnerAPI.TakeDamage then
					local petInfo = nil
					local playerData = PlayerData[player]

					if playerData then
						for _, pet in pairs(playerData.equippedPets) do
							if pet.model == targetPet.model then
								petInfo = pet
								break
							end
						end
					end

					if petInfo then
						local damage = petInfo.damage or 50
						local coinMultiplier = petInfo.coinMultiplier or 1.0

						local destroyed, reward = _G.SpawnerAPI.TakeDamage(targetObject, damage)
						if destroyed and reward then
							local totalReward = math.floor(reward * coinMultiplier)
							playerData.coins = playerData.coins + totalReward
							RE_UpdateCoins:FireClient(player, playerData.coins)
							print("üí∞ " .. player.Name .. " +$" .. totalReward)

							-- –û–±—ä–µ–∫—Ç —É–Ω–∏—á—Ç–æ–∂–µ–Ω - —É–±–∏—Ä–∞–µ–º –æ–±–≤–æ–¥–∫—É
							createBeautifulOutline(targetObject, false)
							break
						end
					end
				else
					-- –ï—Å–ª–∏ –Ω–µ—Ç SpawnerAPI, –ø—Ä–æ—Å—Ç–æ –¥–µ–ª–∞–µ–º –≤–∏–¥ —á—Ç–æ –ª–æ–º–∞–µ–º
					print("üî® " .. targetPet.model:GetAttribute("PetName") .. " –ª–æ–º–∞–µ—Ç " .. targetObject.Name)
				end
			end
		end)
	end
end

-- –û—Ç–∑—ã–≤ –≤—Å–µ—Ö –ø–∏—Ç–æ–º—Ü–µ–≤
local function recallAllPets(player)
	if not PlayerData[player] then return end

	-- –£–±–∏—Ä–∞–µ–º –æ–±–≤–æ–¥–∫—É —Å–æ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤
	for object, _ in pairs(attackedObjects) do
		createBeautifulOutline(object, false)
	end

	-- –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ—Ö –ø–∏—Ç–æ–º—Ü–µ–≤
	for _, petData in pairs(activePets) do
		if petData.player == player then
			petData.model:SetAttribute("State", PET_STATES.FOLLOWING)
			petData.attackTarget = nil
			petData.isAttacking = false
		end
	end

	print("üîô –í—Å–µ –ø–∏—Ç–æ–º—Ü—ã " .. player.Name .. " –æ—Ç–æ–∑–≤–∞–Ω—ã")
end

-- –≠–∫–∏–ø–∏—Ä–æ–≤–∫–∞ –ø–∏—Ç–æ–º—Ü–∞
local function equipPet(player, petId)
	if not PlayerData[player] then return end

	local equippedCount = 0
	for _ in pairs(PlayerData[player].equippedPets) do
		equippedCount = equippedCount + 1
	end

	if equippedCount >= 3 then
		print("‚ùå –õ–∏–º–∏—Ç –ø–∏—Ç–æ–º—Ü–µ–≤ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–ª—è " .. player.Name)
		return
	end

	local petInfo = nil
	for _, pet in pairs(PlayerData[player].pets) do
		if pet.id == petId and not pet.equipped then
			petInfo = pet
			break
		end
	end

	if not petInfo then return end

	local character = player.Character
	if not character then return end

	local petModel = createUltimatePet(petInfo.modelName, player, equippedCount + 1)
	if not petModel then return end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp then
		local spawnCFrame = hrp.CFrame * CFrame.new(0, 0, 8)
		petModel:SetPrimaryPartCFrame(spawnCFrame)
	end

	petModel.Parent = character
	startUltimatePetAI(petModel, player, equippedCount + 1)

	petInfo.equipped = true
	petInfo.model = petModel
	PlayerData[player].equippedPets[petId] = petInfo

	RE_UpdatePets:FireClient(player, PlayerData[player].pets, PlayerData[player].equippedPets)
	print("‚úÖ –ü–∏—Ç–æ–º–µ—Ü —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω: " .. petInfo.name)
end

-- –°–Ω—è—Ç–∏–µ –ø–∏—Ç–æ–º—Ü–∞
local function unequipPet(player, petId)
	if not PlayerData[player] then return end

	local petInfo = PlayerData[player].equippedPets[petId]
	if not petInfo then return end

	for i = #activePets, 1, -1 do
		if activePets[i].model == petInfo.model then
			table.remove(activePets, i)
			break
		end
	end

	if petInfo.model then
		petInfo.model:Destroy()
	end

	petInfo.equipped = false
	petInfo.model = nil
	PlayerData[player].equippedPets[petId] = nil

	-- –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–æ—Ä–º–∞—Ü–∏—é
	local remainingPets = {}
	for _, petData in pairs(activePets) do
		if petData.player == player then
			table.insert(remainingPets, petData)
		end
	end

	local formation = PERFECT_FORMATIONS[math.min(3, #remainingPets)] or PERFECT_FORMATIONS[1]
	for i, petData in ipairs(remainingPets) do
		petData.formationOffset = formation[i]
		petData.formationIndex = i
	end

	RE_UpdatePets:FireClient(player, PlayerData[player].pets, PlayerData[player].equippedPets)
end

-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –ø–∏—Ç–æ–º—Ü–∞
local function deletePet(player, petId)
	if not PlayerData[player] then return end

	local playerData = PlayerData[player]

	-- –ï—Å–ª–∏ –ø–∏—Ç–æ–º–µ—Ü —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω - —Å–Ω–∏–º–∞–µ–º –µ–≥–æ
	if playerData.equippedPets[petId] then
		unequipPet(player, petId)
	end

	-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –º–∞—Å—Å–∏–≤–∞
	for i = #playerData.pets, 1, -1 do
		if playerData.pets[i].id == petId then
			table.remove(playerData.pets, i)
			print("üóëÔ∏è –ü–∏—Ç–æ–º–µ—Ü —É–¥–∞–ª—ë–Ω: " .. petId)
			break
		end
	end

	RE_UpdatePets:FireClient(player, PlayerData[player].pets, PlayerData[player].equippedPets)
end

-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –°–Ω—è—Ç—å –≤—Å–µ—Ö –ø–∏—Ç–æ–º—Ü–µ–≤ (–æ—Ç–¥–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è)
local function unequipAllPets(player)
	if not PlayerData[player] then return end

	local toUnequip = {}
	for petId in pairs(PlayerData[player].equippedPets) do
		table.insert(toUnequip, petId)
	end

	for _, petId in pairs(toUnequip) do
		unequipPet(player, petId)
		task.wait(0.1)
	end

	print("üí§ –í—Å–µ –ø–∏—Ç–æ–º—Ü—ã " .. player.Name .. " —Å–Ω—è—Ç—ã")
end

-- –ò–°–ü–†–ê–í–õ–ï–ù–û: –≠–∫–∏–ø–∏—Ä–æ–≤–∫–∞ –ª—É—á—à–∏—Ö (–Ω–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è)
local function equipBestPets(player)
	if not PlayerData[player] then return end

	-- –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–∏—Ç–æ–º—Ü–µ–≤ –ø–æ —Å–∏–ª–µ
	local sortedPets = {}
	for _, pet in pairs(PlayerData[player].pets) do
		if not pet.equipped then
			table.insert(sortedPets, pet)
		end
	end

	table.sort(sortedPets, function(a, b)
		local powerA = a.damage * a.coinMultiplier
		local powerB = b.damage * b.coinMultiplier
		return powerA > powerB
	end)

	-- –≠–∫–∏–ø–∏—Ä—É–µ–º –ª—É—á—à–∏—Ö (–º–∞–∫—Å–∏–º—É–º 3)
	local maxEquip = math.min(3, #sortedPets)
	for i = 1, maxEquip do
		equipPet(player, sortedPets[i].id)
		task.wait(0.2)
	end

	print("‚ú® –≠–∫–∏–ø–∏—Ä–æ–≤–∞–Ω—ã –ª—É—á—à–∏–µ –ø–∏—Ç–æ–º—Ü—ã –¥–ª—è " .. player.Name)
end

-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
RE_EquipPet.OnServerEvent:Connect(equipPet)
RE_UnequipPet.OnServerEvent:Connect(unequipPet)
RE_SmartAttack.OnServerEvent:Connect(smartAttackSingle)
RE_RecallAllPets.OnServerEvent:Connect(recallAllPets)
RE_DeletePet.OnServerEvent:Connect(deletePet)
RE_EquipBest.OnServerEvent:Connect(equipBestPets)
RE_UnequipAll.OnServerEvent:Connect(unequipAllPets)

-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤
Players.PlayerAdded:Connect(initPlayer)
for _, player in pairs(Players:GetPlayers()) do
	initPlayer(player)
end

-- –û—á–∏—Å—Ç–∫–∞
Players.PlayerRemoving:Connect(function(player)
	if PlayerData[player] then
		for object, _ in pairs(attackedObjects) do
			createBeautifulOutline(object, false)
		end

		for i = #activePets, 1, -1 do
			if activePets[i].player == player then
				table.remove(activePets, i)
			end
		end
		PlayerData[player] = nil
	end
end)

print("üéØ Ultimate Pet System READY!")
print("‚úÖ –í—Å–µ –ø—Ä–æ–±–ª–µ–º—ã –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã:")
print("   üéØ 1 –∫–ª–∏–∫ = 1 –ø–∏—Ç–æ–º–µ—Ü")
print("   üìè –§–æ—Ä–º–∞—Ü–∏–∏: –õ–µ–≤—ã–π-–¶–µ–Ω—Ç—Ä-–ü—Ä–∞–≤—ã–π")
print("   üîµ –ö—Ä–∞—Å–∏–≤–∞—è –æ–±–≤–æ–¥–∫–∞ –æ–±—ä–µ–∫—Ç–æ–≤")
print("   ‚öîÔ∏è –ü–∏—Ç–æ–º—Ü—ã –∞—Ç–∞–∫—É—é—Ç –°–ù–ê–†–£–ñ–ò –æ–±—ä–µ–∫—Ç–∞")
print("   üëÄ –ü–∏—Ç–æ–º—Ü—ã —Å–º–æ—Ç—Ä—è—Ç –ù–ê –æ–±—ä–µ–∫—Ç")
print("   üóëÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ –ø–∏—Ç–æ–º—Ü–µ–≤ —Ä–∞–±–æ—Ç–∞–µ—Ç")
print("   ‚≠ê –ö–Ω–æ–ø–∫–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ")